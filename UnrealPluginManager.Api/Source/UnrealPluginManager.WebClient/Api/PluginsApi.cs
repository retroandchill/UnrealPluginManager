/*
 * Unreal Plugin Manager API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Retro.SimplePage;
using UnrealPluginManager.Core.Model.Plugins;
using UnrealPluginManager.Core.Model.Plugins.Recipes;
using UnrealPluginManager.WebClient.Client;

namespace UnrealPluginManager.WebClient.Api {
  using PluginOverviewPage = Page<PluginOverview>;
  using PluginVersionInfoPage = Page<PluginVersionInfo>;


  /// <summary>
  /// Represents a collection of functions to interact with the API endpoints
  /// </summary>
  public interface IPluginsApiSync : IApiAccessor {

    #region Synchronous Operations

    /// <summary>
    /// Adds or updates the README content for the specified plugin version.
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier for the plugin.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The README content in markdown format to be added or updated. (optional)</param>
    /// <returns>string</returns>
    string AddPluginReadme(Guid pluginId, Guid versionId, string? body = default(string?));

    /// <summary>
    /// Adds or updates the README content for the specified plugin version.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier for the plugin.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The README content in markdown format to be added or updated. (optional)</param>
    /// <returns>ApiResponse of string</returns>
    ApiResponse<string> AddPluginReadmeWithHttpInfo(Guid pluginId, Guid versionId, string? body = default(string?));

    /// <summary>
    /// Retrieves a dependency manifest containing potential versions for the given list of plugin dependencies.
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginDependency">A list of plugin dependencies for which potential versions are to be determined.</param>
    /// <returns>DependencyManifest</returns>
    DependencyManifest GetCandidateDependencies(List<PluginDependency> pluginDependency);

    /// <summary>
    /// Retrieves a dependency manifest containing potential versions for the given list of plugin dependencies.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginDependency">A list of plugin dependencies for which potential versions are to be determined.</param>
    /// <returns>ApiResponse of DependencyManifest</returns>
    ApiResponse<DependencyManifest> GetCandidateDependenciesWithHttpInfo(List<PluginDependency> pluginDependency);

    /// <summary>
    /// Retrieves the dependency tree for a specified plugin.
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose dependency tree is to be retrieved.</param>
    /// <param name="body">An optional version range used to filter dependencies for the plugin. (optional)</param>
    /// <returns>List&lt;PluginSummary&gt;</returns>
    List<PluginSummary> GetDependencyTree(Guid pluginId, string? body = default(string?));

    /// <summary>
    /// Retrieves the dependency tree for a specified plugin.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose dependency tree is to be retrieved.</param>
    /// <param name="body">An optional version range used to filter dependencies for the plugin. (optional)</param>
    /// <returns>ApiResponse of List&lt;PluginSummary&gt;</returns>
    ApiResponse<List<PluginSummary>> GetDependencyTreeWithHttpInfo(Guid pluginId, string? body = default(string?));

    /// <summary>
    /// Retrieves detailed information about the latest version of the specified plugin,  optionally constrained by a version range.
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin to retrieve the latest version for.</param>
    /// <param name="version">An optional version range to filter the plugin&#39;s versions. Defaults to all released versions. (optional)</param>
    /// <returns>PluginVersionInfo</returns>
    PluginVersionInfo GetLatestVersion(Guid pluginId, string? version = default(string?));

    /// <summary>
    /// Retrieves detailed information about the latest version of the specified plugin,  optionally constrained by a version range.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin to retrieve the latest version for.</param>
    /// <param name="version">An optional version range to filter the plugin&#39;s versions. Defaults to all released versions. (optional)</param>
    /// <returns>ApiResponse of PluginVersionInfo</returns>
    ApiResponse<PluginVersionInfo> GetLatestVersionWithHttpInfo(Guid pluginId, string? version = default(string?));

    /// <summary>
    /// Retrieves a paginated list of the latest plugin versions filtered by the specified criteria.
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filter plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="versionRange">The semantic version range to filter the plugin versions. Defaults to all release versions. (optional)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <returns>PluginVersionInfoPage</returns>
    PluginVersionInfoPage GetLatestVersions(string? match = default(string?), string? versionRange = default(string?),
                                            int? page = default(int?), int? size = default(int?));

    /// <summary>
    /// Retrieves a paginated list of the latest plugin versions filtered by the specified criteria.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filter plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="versionRange">The semantic version range to filter the plugin versions. Defaults to all release versions. (optional)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <returns>ApiResponse of PluginVersionInfoPage</returns>
    ApiResponse<PluginVersionInfoPage> GetLatestVersionsWithHttpInfo(string? match = default(string?),
                                                                     string? versionRange = default(string?),
                                                                     int? page = default(int?),
                                                                     int? size = default(int?));

    /// <summary>
    /// Retrieves the readme content for a specific version of a plugin.
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin.</param>
    /// <param name="versionId">The unique identifier of the plugin version.</param>
    /// <returns>string</returns>
    string GetPluginReadme(Guid pluginId, Guid versionId);

    /// <summary>
    /// Retrieves the readme content for a specific version of a plugin.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin.</param>
    /// <param name="versionId">The unique identifier of the plugin version.</param>
    /// <returns>ApiResponse of string</returns>
    ApiResponse<string> GetPluginReadmeWithHttpInfo(Guid pluginId, Guid versionId);

    /// <summary>
    /// Retrieves a paginated list of plugin overviews based on the specified filter and pagination settings.
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filtered plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <returns>PluginOverviewPage</returns>
    PluginOverviewPage GetPlugins(string? match = default(string?), int? page = default(int?),
                                  int? size = default(int?));

    /// <summary>
    /// Retrieves a paginated list of plugin overviews based on the specified filter and pagination settings.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filtered plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <returns>ApiResponse of PluginOverviewPage</returns>
    ApiResponse<PluginOverviewPage> GetPluginsWithHttpInfo(string? match = default(string?), int? page = default(int?),
                                                           int? size = default(int?));

    /// <summary>
    /// Submits a new plugin version along with optional icon and README information.
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="manifest"></param>
    /// <param name="icon"> (optional)</param>
    /// <param name="readme"> (optional)</param>
    /// <returns>PluginVersionInfo</returns>
    PluginVersionInfo SubmitPlugin(PluginManifest manifest, FileParameter? icon = default(FileParameter?),
                                   string? readme = default(string?));

    /// <summary>
    /// Submits a new plugin version along with optional icon and README information.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="manifest"></param>
    /// <param name="icon"> (optional)</param>
    /// <param name="readme"> (optional)</param>
    /// <returns>ApiResponse of PluginVersionInfo</returns>
    ApiResponse<PluginVersionInfo> SubmitPluginWithHttpInfo(PluginManifest manifest,
                                                            FileParameter? icon = default(FileParameter?),
                                                            string? readme = default(string?));

    /// <summary>
    /// Updates the README content for a specific plugin version.
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose README is being updated.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The new README content to replace the existing one. (optional)</param>
    /// <returns>string</returns>
    string UpdatePluginReadme(Guid pluginId, Guid versionId, string? body = default(string?));

    /// <summary>
    /// Updates the README content for a specific plugin version.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose README is being updated.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The new README content to replace the existing one. (optional)</param>
    /// <returns>ApiResponse of string</returns>
    ApiResponse<string> UpdatePluginReadmeWithHttpInfo(Guid pluginId, Guid versionId, string? body = default(string?));

    #endregion Synchronous Operations

  }

  /// <summary>
  /// Represents a collection of functions to interact with the API endpoints
  /// </summary>
  public interface IPluginsApiAsync : IApiAccessor {

    #region Asynchronous Operations

    /// <summary>
    /// Adds or updates the README content for the specified plugin version.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier for the plugin.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The README content in markdown format to be added or updated. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of string</returns>
    Task<string> AddPluginReadmeAsync(Guid pluginId, Guid versionId, string? body = default(string?),
                                      CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// Adds or updates the README content for the specified plugin version.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier for the plugin.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The README content in markdown format to be added or updated. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (string)</returns>
    Task<ApiResponse<string>> AddPluginReadmeWithHttpInfoAsync(Guid pluginId, Guid versionId,
                                                               string? body = default(string?),
                                                               CancellationToken cancellationToken =
                                                                   default(CancellationToken));

    /// <summary>
    /// Retrieves a dependency manifest containing potential versions for the given list of plugin dependencies.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginDependency">A list of plugin dependencies for which potential versions are to be determined.</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of DependencyManifest</returns>
    Task<DependencyManifest> GetCandidateDependenciesAsync(List<PluginDependency> pluginDependency,
                                                           CancellationToken cancellationToken =
                                                               default(CancellationToken));

    /// <summary>
    /// Retrieves a dependency manifest containing potential versions for the given list of plugin dependencies.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginDependency">A list of plugin dependencies for which potential versions are to be determined.</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (DependencyManifest)</returns>
    Task<ApiResponse<DependencyManifest>> GetCandidateDependenciesWithHttpInfoAsync(
        List<PluginDependency> pluginDependency, CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// Retrieves the dependency tree for a specified plugin.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose dependency tree is to be retrieved.</param>
    /// <param name="body">An optional version range used to filter dependencies for the plugin. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;PluginSummary&gt;</returns>
    Task<List<PluginSummary>> GetDependencyTreeAsync(Guid pluginId, string? body = default(string?),
                                                     CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// Retrieves the dependency tree for a specified plugin.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose dependency tree is to be retrieved.</param>
    /// <param name="body">An optional version range used to filter dependencies for the plugin. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;PluginSummary&gt;)</returns>
    Task<ApiResponse<List<PluginSummary>>> GetDependencyTreeWithHttpInfoAsync(
        Guid pluginId, string? body = default(string?),
        CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// Retrieves detailed information about the latest version of the specified plugin,  optionally constrained by a version range.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin to retrieve the latest version for.</param>
    /// <param name="version">An optional version range to filter the plugin&#39;s versions. Defaults to all released versions. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of PluginVersionInfo</returns>
    Task<PluginVersionInfo> GetLatestVersionAsync(Guid pluginId, string? version = default(string?),
                                                  CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// Retrieves detailed information about the latest version of the specified plugin,  optionally constrained by a version range.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin to retrieve the latest version for.</param>
    /// <param name="version">An optional version range to filter the plugin&#39;s versions. Defaults to all released versions. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (PluginVersionInfo)</returns>
    Task<ApiResponse<PluginVersionInfo>> GetLatestVersionWithHttpInfoAsync(
        Guid pluginId, string? version = default(string?),
        CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// Retrieves a paginated list of the latest plugin versions filtered by the specified criteria.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filter plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="versionRange">The semantic version range to filter the plugin versions. Defaults to all release versions. (optional)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of PluginVersionInfoPage</returns>
    Task<PluginVersionInfoPage> GetLatestVersionsAsync(string? match = default(string?),
                                                       string? versionRange = default(string?),
                                                       int? page = default(int?), int? size = default(int?),
                                                       CancellationToken cancellationToken =
                                                           default(CancellationToken));

    /// <summary>
    /// Retrieves a paginated list of the latest plugin versions filtered by the specified criteria.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filter plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="versionRange">The semantic version range to filter the plugin versions. Defaults to all release versions. (optional)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (PluginVersionInfoPage)</returns>
    Task<ApiResponse<PluginVersionInfoPage>> GetLatestVersionsWithHttpInfoAsync(
        string? match = default(string?), string? versionRange = default(string?), int? page = default(int?),
        int? size = default(int?), CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// Retrieves the readme content for a specific version of a plugin.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin.</param>
    /// <param name="versionId">The unique identifier of the plugin version.</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of string</returns>
    Task<string> GetPluginReadmeAsync(Guid pluginId, Guid versionId,
                                      CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// Retrieves the readme content for a specific version of a plugin.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin.</param>
    /// <param name="versionId">The unique identifier of the plugin version.</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (string)</returns>
    Task<ApiResponse<string>> GetPluginReadmeWithHttpInfoAsync(Guid pluginId, Guid versionId,
                                                               CancellationToken cancellationToken =
                                                                   default(CancellationToken));

    /// <summary>
    /// Retrieves a paginated list of plugin overviews based on the specified filter and pagination settings.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filtered plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of PluginOverviewPage</returns>
    Task<PluginOverviewPage> GetPluginsAsync(string? match = default(string?), int? page = default(int?),
                                             int? size = default(int?),
                                             CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// Retrieves a paginated list of plugin overviews based on the specified filter and pagination settings.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filtered plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (PluginOverviewPage)</returns>
    Task<ApiResponse<PluginOverviewPage>> GetPluginsWithHttpInfoAsync(string? match = default(string?),
                                                                      int? page = default(int?),
                                                                      int? size = default(int?),
                                                                      CancellationToken cancellationToken =
                                                                          default(CancellationToken));

    /// <summary>
    /// Submits a new plugin version along with optional icon and README information.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="manifest"></param>
    /// <param name="icon"> (optional)</param>
    /// <param name="readme"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of PluginVersionInfo</returns>
    Task<PluginVersionInfo> SubmitPluginAsync(PluginManifest manifest, FileParameter? icon = default(FileParameter?),
                                              string? readme = default(string?),
                                              CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// Submits a new plugin version along with optional icon and README information.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="manifest"></param>
    /// <param name="icon"> (optional)</param>
    /// <param name="readme"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (PluginVersionInfo)</returns>
    Task<ApiResponse<PluginVersionInfo>> SubmitPluginWithHttpInfoAsync(PluginManifest manifest,
                                                                       FileParameter? icon = default(FileParameter?),
                                                                       string? readme = default(string?),
                                                                       CancellationToken cancellationToken =
                                                                           default(CancellationToken));

    /// <summary>
    /// Updates the README content for a specific plugin version.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose README is being updated.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The new README content to replace the existing one. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of string</returns>
    Task<string> UpdatePluginReadmeAsync(Guid pluginId, Guid versionId, string? body = default(string?),
                                         CancellationToken cancellationToken = default(CancellationToken));

    /// <summary>
    /// Updates the README content for a specific plugin version.
    /// </summary>
    /// <remarks>
    /// 
    /// </remarks>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose README is being updated.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The new README content to replace the existing one. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (string)</returns>
    Task<ApiResponse<string>> UpdatePluginReadmeWithHttpInfoAsync(Guid pluginId, Guid versionId,
                                                                  string? body = default(string?),
                                                                  CancellationToken cancellationToken =
                                                                      default(CancellationToken));

    #endregion Asynchronous Operations

  }

  /// <summary>
  /// Represents a collection of functions to interact with the API endpoints
  /// </summary>
  public interface IPluginsApi : IPluginsApiSync, IPluginsApiAsync {

  }

  /// <summary>
  /// Represents a collection of functions to interact with the API endpoints
  /// </summary>
  public partial class PluginsApi : IDisposable, IPluginsApi {
    private ExceptionFactory _exceptionFactory = (name, response) => null;

    /// <summary>
    /// Initializes a new instance of the <see cref="PluginsApi"/> class.
    /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
    /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
    /// </summary>
    /// <returns></returns>
    public PluginsApi() : this((string) null) {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PluginsApi"/> class.
    /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
    /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
    /// </summary>
    /// <param name="basePath">The target service's base path in URL format.</param>
    /// <exception cref="ArgumentException"></exception>
    /// <returns></returns>
    public PluginsApi(string basePath) {
      this.Configuration = WebClient.Client.Configuration.MergeConfigurations(
          GlobalConfiguration.Instance,
          new Configuration {
              BasePath = basePath
          }
      );
      this.ApiClient = new ApiClient(this.Configuration.BasePath);
      this.Client = this.ApiClient;
      this.AsynchronousClient = this.ApiClient;
      this.ExceptionFactory = WebClient.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PluginsApi"/> class using Configuration object.
    /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
    /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
    /// </summary>
    /// <param name="configuration">An instance of Configuration.</param>
    /// <exception cref="ArgumentNullException"></exception>
    /// <returns></returns>
    public PluginsApi(Configuration configuration) {
      if (configuration == null) throw new ArgumentNullException("configuration");

      this.Configuration = WebClient.Client.Configuration.MergeConfigurations(
          GlobalConfiguration.Instance,
          configuration
      );
      this.ApiClient = new ApiClient(this.Configuration.BasePath);
      this.Client = this.ApiClient;
      this.AsynchronousClient = this.ApiClient;
      ExceptionFactory = WebClient.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PluginsApi"/> class.
    /// </summary>
    /// <param name="client">An instance of HttpClient.</param>
    /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
    /// <exception cref="ArgumentNullException"></exception>
    /// <returns></returns>
    /// <remarks>
    /// Some configuration settings will not be applied without passing an HttpClientHandler.
    /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
    /// </remarks>
    public PluginsApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string) null, handler) {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PluginsApi"/> class.
    /// </summary>
    /// <param name="client">An instance of HttpClient.</param>
    /// <param name="basePath">The target service's base path in URL format.</param>
    /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
    /// <exception cref="ArgumentNullException"></exception>
    /// <exception cref="ArgumentException"></exception>
    /// <returns></returns>
    /// <remarks>
    /// Some configuration settings will not be applied without passing an HttpClientHandler.
    /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
    /// </remarks>
    public PluginsApi(HttpClient client, string basePath, HttpClientHandler handler = null) {
      if (client == null) throw new ArgumentNullException("client");

      this.Configuration = WebClient.Client.Configuration.MergeConfigurations(
          GlobalConfiguration.Instance,
          new Configuration {
              BasePath = basePath
          }
      );
      this.ApiClient = new ApiClient(client, this.Configuration.BasePath, handler);
      this.Client = this.ApiClient;
      this.AsynchronousClient = this.ApiClient;
      this.ExceptionFactory = WebClient.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PluginsApi"/> class using Configuration object.
    /// </summary>
    /// <param name="client">An instance of HttpClient.</param>
    /// <param name="configuration">An instance of Configuration.</param>
    /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
    /// <exception cref="ArgumentNullException"></exception>
    /// <returns></returns>
    /// <remarks>
    /// Some configuration settings will not be applied without passing an HttpClientHandler.
    /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
    /// </remarks>
    public PluginsApi(HttpClient client, Configuration configuration, HttpClientHandler handler = null) {
      if (configuration == null) throw new ArgumentNullException("configuration");
      if (client == null) throw new ArgumentNullException("client");

      this.Configuration = WebClient.Client.Configuration.MergeConfigurations(
          GlobalConfiguration.Instance,
          configuration
      );
      this.ApiClient = new ApiClient(client, this.Configuration.BasePath, handler);
      this.Client = this.ApiClient;
      this.AsynchronousClient = this.ApiClient;
      ExceptionFactory = WebClient.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PluginsApi"/> class
    /// using a Configuration object and client instance.
    /// </summary>
    /// <param name="client">The client interface for synchronous API access.</param>
    /// <param name="asyncClient">The client interface for asynchronous API access.</param>
    /// <param name="configuration">The configuration object.</param>
    /// <exception cref="ArgumentNullException"></exception>
    public PluginsApi(ISynchronousClient client, IAsynchronousClient asyncClient,
                      IReadableConfiguration configuration) {
      if (client == null) throw new ArgumentNullException("client");
      if (asyncClient == null) throw new ArgumentNullException("asyncClient");
      if (configuration == null) throw new ArgumentNullException("configuration");

      this.Client = client;
      this.AsynchronousClient = asyncClient;
      this.Configuration = configuration;
      this.ExceptionFactory = WebClient.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// Disposes resources if they were created by us
    /// </summary>
    public void Dispose() {
      this.ApiClient?.Dispose();
    }

    /// <summary>
    /// Holds the ApiClient if created
    /// </summary>
    public ApiClient ApiClient { get; set; } = null;

    /// <summary>
    /// The client for accessing this underlying API asynchronously.
    /// </summary>
    public IAsynchronousClient AsynchronousClient { get; set; }

    /// <summary>
    /// The client for accessing this underlying API synchronously.
    /// </summary>
    public ISynchronousClient Client { get; set; }

    /// <summary>
    /// Gets the base path of the API client.
    /// </summary>
    /// <value>The base path</value>
    public string GetBasePath() {
      return this.Configuration.BasePath;
    }

    /// <summary>
    /// Gets or sets the configuration object
    /// </summary>
    /// <value>An instance of the Configuration</value>
    public IReadableConfiguration Configuration { get; set; }

    /// <summary>
    /// Provides a factory method hook for the creation of exceptions.
    /// </summary>
    public ExceptionFactory ExceptionFactory {
      get {
        if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1) {
          throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
        }
        return _exceptionFactory;
      }
      set { _exceptionFactory = value; }
    }

    /// <summary>
    /// Adds or updates the README content for the specified plugin version. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier for the plugin.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The README content in markdown format to be added or updated. (optional)</param>
    /// <returns>string</returns>
    public string AddPluginReadme(Guid pluginId, Guid versionId, string? body = default(string?)) {
      ApiResponse<string> localVarResponse = AddPluginReadmeWithHttpInfo(pluginId, versionId, body);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Adds or updates the README content for the specified plugin version. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier for the plugin.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The README content in markdown format to be added or updated. (optional)</param>
    /// <returns>ApiResponse of string</returns>
    public ApiResponse<string> AddPluginReadmeWithHttpInfo(Guid pluginId, Guid versionId,
                                                           string? body = default(string?)) {
      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
          "text/markdown", "application/json"
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "text/markdown"
      };

      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.PathParameters.Add("pluginId", ClientUtils.ParameterToString(pluginId)); // path parameter
      localVarRequestOptions.PathParameters.Add("versionId",
          ClientUtils.ParameterToString(versionId)); // path parameter
      localVarRequestOptions.Data = body;

      // authentication (apiKey) required
      if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Key"))) {
        localVarRequestOptions.HeaderParameters.Add("X-API-Key", this.Configuration.GetApiKeyWithPrefix("X-API-Key"));
      }
      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request
      var localVarResponse = this.Client.Post<string>("/plugins/{pluginId}/{versionId}/readme", localVarRequestOptions,
          this.Configuration);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("AddPluginReadme", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Adds or updates the README content for the specified plugin version. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier for the plugin.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The README content in markdown format to be added or updated. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of string</returns>
    public async Task<string> AddPluginReadmeAsync(Guid pluginId, Guid versionId, string? body = default(string?),
                                                   CancellationToken cancellationToken = default(CancellationToken)) {
      ApiResponse<string> localVarResponse =
          await AddPluginReadmeWithHttpInfoAsync(pluginId, versionId, body, cancellationToken).ConfigureAwait(false);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Adds or updates the README content for the specified plugin version. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier for the plugin.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The README content in markdown format to be added or updated. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (string)</returns>
    public async Task<ApiResponse<string>> AddPluginReadmeWithHttpInfoAsync(
        Guid pluginId, Guid versionId, string? body = default(string?),
        CancellationToken cancellationToken = default(CancellationToken)) {

      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
          "text/markdown", "application/json"
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "text/markdown"
      };


      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.PathParameters.Add("pluginId", ClientUtils.ParameterToString(pluginId)); // path parameter
      localVarRequestOptions.PathParameters.Add("versionId",
          ClientUtils.ParameterToString(versionId)); // path parameter
      localVarRequestOptions.Data = body;

      // authentication (apiKey) required
      if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Key"))) {
        localVarRequestOptions.HeaderParameters.Add("X-API-Key", this.Configuration.GetApiKeyWithPrefix("X-API-Key"));
      }
      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request

      var localVarResponse = await this.AsynchronousClient.PostAsync<string>("/plugins/{pluginId}/{versionId}/readme",
          localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("AddPluginReadme", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves a dependency manifest containing potential versions for the given list of plugin dependencies. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginDependency">A list of plugin dependencies for which potential versions are to be determined.</param>
    /// <returns>DependencyManifest</returns>
    public DependencyManifest GetCandidateDependencies(List<PluginDependency> pluginDependency) {
      ApiResponse<DependencyManifest> localVarResponse = GetCandidateDependenciesWithHttpInfo(pluginDependency);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves a dependency manifest containing potential versions for the given list of plugin dependencies. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginDependency">A list of plugin dependencies for which potential versions are to be determined.</param>
    /// <returns>ApiResponse of DependencyManifest</returns>
    public ApiResponse<DependencyManifest>
        GetCandidateDependenciesWithHttpInfo(List<PluginDependency> pluginDependency) {
      // verify the required parameter 'pluginDependency' is set
      if (pluginDependency == null)
        throw new ApiException(400,
            "Missing required parameter 'pluginDependency' when calling PluginsApi->GetCandidateDependencies");

      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
          "application/json"
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };

      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.Data = pluginDependency;

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request
      var localVarResponse = this.Client.Get<DependencyManifest>("/plugins/dependencies/candidates",
          localVarRequestOptions, this.Configuration);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetCandidateDependencies", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves a dependency manifest containing potential versions for the given list of plugin dependencies. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginDependency">A list of plugin dependencies for which potential versions are to be determined.</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of DependencyManifest</returns>
    public async Task<DependencyManifest> GetCandidateDependenciesAsync(List<PluginDependency> pluginDependency,
                                                                        CancellationToken cancellationToken =
                                                                            default(CancellationToken)) {
      ApiResponse<DependencyManifest> localVarResponse =
          await GetCandidateDependenciesWithHttpInfoAsync(pluginDependency, cancellationToken).ConfigureAwait(false);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves a dependency manifest containing potential versions for the given list of plugin dependencies. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginDependency">A list of plugin dependencies for which potential versions are to be determined.</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (DependencyManifest)</returns>
    public async Task<ApiResponse<DependencyManifest>> GetCandidateDependenciesWithHttpInfoAsync(
        List<PluginDependency> pluginDependency, CancellationToken cancellationToken = default(CancellationToken)) {
      // verify the required parameter 'pluginDependency' is set
      if (pluginDependency == null)
        throw new ApiException(400,
            "Missing required parameter 'pluginDependency' when calling PluginsApi->GetCandidateDependencies");


      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
          "application/json"
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };


      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.Data = pluginDependency;

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request

      var localVarResponse = await this.AsynchronousClient
          .GetAsync<DependencyManifest>("/plugins/dependencies/candidates", localVarRequestOptions, this.Configuration,
              cancellationToken).ConfigureAwait(false);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetCandidateDependencies", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves the dependency tree for a specified plugin. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose dependency tree is to be retrieved.</param>
    /// <param name="body">An optional version range used to filter dependencies for the plugin. (optional)</param>
    /// <returns>List&lt;PluginSummary&gt;</returns>
    public List<PluginSummary> GetDependencyTree(Guid pluginId, string? body = default(string?)) {
      ApiResponse<List<PluginSummary>> localVarResponse = GetDependencyTreeWithHttpInfo(pluginId, body);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves the dependency tree for a specified plugin. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose dependency tree is to be retrieved.</param>
    /// <param name="body">An optional version range used to filter dependencies for the plugin. (optional)</param>
    /// <returns>ApiResponse of List&lt;PluginSummary&gt;</returns>
    public ApiResponse<List<PluginSummary>> GetDependencyTreeWithHttpInfo(
        Guid pluginId, string? body = default(string?)) {
      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
          "application/json", "text/json", "application/*+json"
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };

      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.PathParameters.Add("pluginId", ClientUtils.ParameterToString(pluginId)); // path parameter
      localVarRequestOptions.Data = body;

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request
      var localVarResponse = this.Client.Get<List<PluginSummary>>("/plugins/{pluginId}/latest/dependencies",
          localVarRequestOptions, this.Configuration);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetDependencyTree", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves the dependency tree for a specified plugin. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose dependency tree is to be retrieved.</param>
    /// <param name="body">An optional version range used to filter dependencies for the plugin. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;PluginSummary&gt;</returns>
    public async Task<List<PluginSummary>> GetDependencyTreeAsync(Guid pluginId, string? body = default(string?),
                                                                  CancellationToken cancellationToken =
                                                                      default(CancellationToken)) {
      ApiResponse<List<PluginSummary>> localVarResponse =
          await GetDependencyTreeWithHttpInfoAsync(pluginId, body, cancellationToken).ConfigureAwait(false);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves the dependency tree for a specified plugin. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose dependency tree is to be retrieved.</param>
    /// <param name="body">An optional version range used to filter dependencies for the plugin. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;PluginSummary&gt;)</returns>
    public async Task<ApiResponse<List<PluginSummary>>> GetDependencyTreeWithHttpInfoAsync(
        Guid pluginId, string? body = default(string?),
        CancellationToken cancellationToken = default(CancellationToken)) {

      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
          "application/json", "text/json", "application/*+json"
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };


      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.PathParameters.Add("pluginId", ClientUtils.ParameterToString(pluginId)); // path parameter
      localVarRequestOptions.Data = body;

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request

      var localVarResponse = await this.AsynchronousClient
          .GetAsync<List<PluginSummary>>("/plugins/{pluginId}/latest/dependencies", localVarRequestOptions,
              this.Configuration, cancellationToken).ConfigureAwait(false);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetDependencyTree", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves detailed information about the latest version of the specified plugin,  optionally constrained by a version range. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin to retrieve the latest version for.</param>
    /// <param name="version">An optional version range to filter the plugin&#39;s versions. Defaults to all released versions. (optional)</param>
    /// <returns>PluginVersionInfo</returns>
    public PluginVersionInfo GetLatestVersion(Guid pluginId, string? version = default(string?)) {
      ApiResponse<PluginVersionInfo> localVarResponse = GetLatestVersionWithHttpInfo(pluginId, version);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves detailed information about the latest version of the specified plugin,  optionally constrained by a version range. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin to retrieve the latest version for.</param>
    /// <param name="version">An optional version range to filter the plugin&#39;s versions. Defaults to all released versions. (optional)</param>
    /// <returns>ApiResponse of PluginVersionInfo</returns>
    public ApiResponse<PluginVersionInfo> GetLatestVersionWithHttpInfo(Guid pluginId,
                                                                       string? version = default(string?)) {
      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };

      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.PathParameters.Add("pluginId", ClientUtils.ParameterToString(pluginId)); // path parameter
      if (version != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "version", version));
      }

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request
      var localVarResponse =
          this.Client.Get<PluginVersionInfo>("/plugins/{pluginId}/latest", localVarRequestOptions, this.Configuration);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetLatestVersion", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves detailed information about the latest version of the specified plugin,  optionally constrained by a version range. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin to retrieve the latest version for.</param>
    /// <param name="version">An optional version range to filter the plugin&#39;s versions. Defaults to all released versions. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of PluginVersionInfo</returns>
    public async Task<PluginVersionInfo> GetLatestVersionAsync(Guid pluginId, string? version = default(string?),
                                                               CancellationToken cancellationToken =
                                                                   default(CancellationToken)) {
      ApiResponse<PluginVersionInfo> localVarResponse =
          await GetLatestVersionWithHttpInfoAsync(pluginId, version, cancellationToken).ConfigureAwait(false);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves detailed information about the latest version of the specified plugin,  optionally constrained by a version range. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin to retrieve the latest version for.</param>
    /// <param name="version">An optional version range to filter the plugin&#39;s versions. Defaults to all released versions. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (PluginVersionInfo)</returns>
    public async Task<ApiResponse<PluginVersionInfo>> GetLatestVersionWithHttpInfoAsync(
        Guid pluginId, string? version = default(string?),
        CancellationToken cancellationToken = default(CancellationToken)) {

      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };


      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.PathParameters.Add("pluginId", ClientUtils.ParameterToString(pluginId)); // path parameter
      if (version != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "version", version));
      }

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request

      var localVarResponse = await this.AsynchronousClient.GetAsync<PluginVersionInfo>("/plugins/{pluginId}/latest",
          localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetLatestVersion", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves a paginated list of the latest plugin versions filtered by the specified criteria. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filter plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="versionRange">The semantic version range to filter the plugin versions. Defaults to all release versions. (optional)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <returns>PluginVersionInfoPage</returns>
    public PluginVersionInfoPage GetLatestVersions(string? match = default(string?),
                                                   string? versionRange = default(string?), int? page = default(int?),
                                                   int? size = default(int?)) {
      ApiResponse<PluginVersionInfoPage> localVarResponse =
          GetLatestVersionsWithHttpInfo(match, versionRange, page, size);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves a paginated list of the latest plugin versions filtered by the specified criteria. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filter plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="versionRange">The semantic version range to filter the plugin versions. Defaults to all release versions. (optional)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <returns>ApiResponse of PluginVersionInfoPage</returns>
    public ApiResponse<PluginVersionInfoPage> GetLatestVersionsWithHttpInfo(
        string? match = default(string?), string? versionRange = default(string?), int? page = default(int?),
        int? size = default(int?)) {
      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };

      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      if (match != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "match", match));
      }
      if (versionRange != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "versionRange", versionRange));
      }
      if (page != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
      }
      if (size != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "size", size));
      }

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request
      var localVarResponse =
          this.Client.Get<PluginVersionInfoPage>("/plugins/latest", localVarRequestOptions, this.Configuration);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetLatestVersions", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves a paginated list of the latest plugin versions filtered by the specified criteria. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filter plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="versionRange">The semantic version range to filter the plugin versions. Defaults to all release versions. (optional)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of PluginVersionInfoPage</returns>
    public async Task<PluginVersionInfoPage> GetLatestVersionsAsync(string? match = default(string?),
                                                                    string? versionRange = default(string?),
                                                                    int? page = default(int?),
                                                                    int? size = default(int?),
                                                                    CancellationToken cancellationToken =
                                                                        default(CancellationToken)) {
      ApiResponse<PluginVersionInfoPage> localVarResponse =
          await GetLatestVersionsWithHttpInfoAsync(match, versionRange, page, size, cancellationToken)
              .ConfigureAwait(false);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves a paginated list of the latest plugin versions filtered by the specified criteria. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filter plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="versionRange">The semantic version range to filter the plugin versions. Defaults to all release versions. (optional)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (PluginVersionInfoPage)</returns>
    public async Task<ApiResponse<PluginVersionInfoPage>> GetLatestVersionsWithHttpInfoAsync(
        string? match = default(string?), string? versionRange = default(string?), int? page = default(int?),
        int? size = default(int?), CancellationToken cancellationToken = default(CancellationToken)) {

      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };


      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      if (match != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "match", match));
      }
      if (versionRange != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "versionRange", versionRange));
      }
      if (page != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
      }
      if (size != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "size", size));
      }

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request

      var localVarResponse = await this.AsynchronousClient
          .GetAsync<PluginVersionInfoPage>("/plugins/latest", localVarRequestOptions, this.Configuration,
              cancellationToken).ConfigureAwait(false);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetLatestVersions", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves the readme content for a specific version of a plugin. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin.</param>
    /// <param name="versionId">The unique identifier of the plugin version.</param>
    /// <returns>string</returns>
    public string GetPluginReadme(Guid pluginId, Guid versionId) {
      ApiResponse<string> localVarResponse = GetPluginReadmeWithHttpInfo(pluginId, versionId);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves the readme content for a specific version of a plugin. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin.</param>
    /// <param name="versionId">The unique identifier of the plugin version.</param>
    /// <returns>ApiResponse of string</returns>
    public ApiResponse<string> GetPluginReadmeWithHttpInfo(Guid pluginId, Guid versionId) {
      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "text/markdown"
      };

      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.PathParameters.Add("pluginId", ClientUtils.ParameterToString(pluginId)); // path parameter
      localVarRequestOptions.PathParameters.Add("versionId",
          ClientUtils.ParameterToString(versionId)); // path parameter

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request
      var localVarResponse = this.Client.Get<string>("/plugins/{pluginId}/{versionId}/readme", localVarRequestOptions,
          this.Configuration);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetPluginReadme", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves the readme content for a specific version of a plugin. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin.</param>
    /// <param name="versionId">The unique identifier of the plugin version.</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of string</returns>
    public async Task<string> GetPluginReadmeAsync(Guid pluginId, Guid versionId,
                                                   CancellationToken cancellationToken = default(CancellationToken)) {
      ApiResponse<string> localVarResponse =
          await GetPluginReadmeWithHttpInfoAsync(pluginId, versionId, cancellationToken).ConfigureAwait(false);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves the readme content for a specific version of a plugin. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin.</param>
    /// <param name="versionId">The unique identifier of the plugin version.</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (string)</returns>
    public async Task<ApiResponse<string>> GetPluginReadmeWithHttpInfoAsync(
        Guid pluginId, Guid versionId, CancellationToken cancellationToken = default(CancellationToken)) {

      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "text/markdown"
      };


      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.PathParameters.Add("pluginId", ClientUtils.ParameterToString(pluginId)); // path parameter
      localVarRequestOptions.PathParameters.Add("versionId",
          ClientUtils.ParameterToString(versionId)); // path parameter

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request

      var localVarResponse = await this.AsynchronousClient.GetAsync<string>("/plugins/{pluginId}/{versionId}/readme",
          localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetPluginReadme", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves a paginated list of plugin overviews based on the specified filter and pagination settings. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filtered plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <returns>PluginOverviewPage</returns>
    public PluginOverviewPage GetPlugins(string? match = default(string?), int? page = default(int?),
                                         int? size = default(int?)) {
      ApiResponse<PluginOverviewPage> localVarResponse = GetPluginsWithHttpInfo(match, page, size);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves a paginated list of plugin overviews based on the specified filter and pagination settings. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filtered plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <returns>ApiResponse of PluginOverviewPage</returns>
    public ApiResponse<PluginOverviewPage> GetPluginsWithHttpInfo(string? match = default(string?),
                                                                  int? page = default(int?),
                                                                  int? size = default(int?)) {
      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };

      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      if (match != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "match", match));
      }
      if (page != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
      }
      if (size != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "size", size));
      }

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request
      var localVarResponse =
          this.Client.Get<PluginOverviewPage>("/plugins", localVarRequestOptions, this.Configuration);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetPlugins", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Retrieves a paginated list of plugin overviews based on the specified filter and pagination settings. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filtered plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of PluginOverviewPage</returns>
    public async Task<PluginOverviewPage> GetPluginsAsync(string? match = default(string?), int? page = default(int?),
                                                          int? size = default(int?),
                                                          CancellationToken cancellationToken =
                                                              default(CancellationToken)) {
      ApiResponse<PluginOverviewPage> localVarResponse =
          await GetPluginsWithHttpInfoAsync(match, page, size, cancellationToken).ConfigureAwait(false);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Retrieves a paginated list of plugin overviews based on the specified filter and pagination settings. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="match">A wildcard string used to filtered plugins by name. Defaults to \&quot;*\&quot;. (optional, default to &quot;&quot;)</param>
    /// <param name="page">The page number to retrieve. (optional, default to 1)</param>
    /// <param name="size">The number of items to retrieve per page. (optional, default to 10)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (PluginOverviewPage)</returns>
    public async Task<ApiResponse<PluginOverviewPage>> GetPluginsWithHttpInfoAsync(
        string? match = default(string?), int? page = default(int?), int? size = default(int?),
        CancellationToken cancellationToken = default(CancellationToken)) {

      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };


      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      if (match != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "match", match));
      }
      if (page != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "page", page));
      }
      if (size != null) {
        localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "size", size));
      }

      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request

      var localVarResponse = await this.AsynchronousClient
          .GetAsync<PluginOverviewPage>("/plugins", localVarRequestOptions, this.Configuration, cancellationToken)
          .ConfigureAwait(false);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("GetPlugins", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Submits a new plugin version along with optional icon and README information. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="manifest"></param>
    /// <param name="icon"> (optional)</param>
    /// <param name="readme"> (optional)</param>
    /// <returns>PluginVersionInfo</returns>
    public PluginVersionInfo SubmitPlugin(PluginManifest manifest, FileParameter? icon = default(FileParameter?),
                                          string? readme = default(string?)) {
      ApiResponse<PluginVersionInfo> localVarResponse = SubmitPluginWithHttpInfo(manifest, icon, readme);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Submits a new plugin version along with optional icon and README information. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="manifest"></param>
    /// <param name="icon"> (optional)</param>
    /// <param name="readme"> (optional)</param>
    /// <returns>ApiResponse of PluginVersionInfo</returns>
    public ApiResponse<PluginVersionInfo> SubmitPluginWithHttpInfo(PluginManifest manifest,
                                                                   FileParameter? icon = default(FileParameter?),
                                                                   string? readme = default(string?)) {
      // verify the required parameter 'manifest' is set
      if (manifest == null)
        throw new ApiException(400, "Missing required parameter 'manifest' when calling PluginsApi->SubmitPlugin");

      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
          "multipart/form-data"
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };

      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.FormParameters.Add("manifest", ClientUtils.ParameterToString(manifest)); // form parameter
      if (icon != null) {
        localVarRequestOptions.FileParameters.Add("icon", icon);
      }
      if (readme != null) {
        localVarRequestOptions.FormParameters.Add("readme", ClientUtils.ParameterToString(readme)); // form parameter
      }

      // authentication (apiKey) required
      if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Key"))) {
        localVarRequestOptions.HeaderParameters.Add("X-API-Key", this.Configuration.GetApiKeyWithPrefix("X-API-Key"));
      }
      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request
      var localVarResponse =
          this.Client.Post<PluginVersionInfo>("/plugins", localVarRequestOptions, this.Configuration);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("SubmitPlugin", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Submits a new plugin version along with optional icon and README information. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="manifest"></param>
    /// <param name="icon"> (optional)</param>
    /// <param name="readme"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of PluginVersionInfo</returns>
    public async Task<PluginVersionInfo> SubmitPluginAsync(PluginManifest manifest,
                                                           FileParameter? icon = default(FileParameter?),
                                                           string? readme = default(string?),
                                                           CancellationToken cancellationToken =
                                                               default(CancellationToken)) {
      ApiResponse<PluginVersionInfo> localVarResponse =
          await SubmitPluginWithHttpInfoAsync(manifest, icon, readme, cancellationToken).ConfigureAwait(false);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Submits a new plugin version along with optional icon and README information. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="manifest"></param>
    /// <param name="icon"> (optional)</param>
    /// <param name="readme"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (PluginVersionInfo)</returns>
    public async Task<ApiResponse<PluginVersionInfo>> SubmitPluginWithHttpInfoAsync(
        PluginManifest manifest, FileParameter? icon = default(FileParameter?), string? readme = default(string?),
        CancellationToken cancellationToken = default(CancellationToken)) {
      // verify the required parameter 'manifest' is set
      if (manifest == null)
        throw new ApiException(400, "Missing required parameter 'manifest' when calling PluginsApi->SubmitPlugin");


      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
          "multipart/form-data"
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "application/json"
      };


      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.FormParameters.Add("manifest", ClientUtils.ParameterToString(manifest)); // form parameter
      if (icon != null) {
        localVarRequestOptions.FileParameters.Add("icon", icon);
      }
      if (readme != null) {
        localVarRequestOptions.FormParameters.Add("readme", ClientUtils.ParameterToString(readme)); // form parameter
      }

      // authentication (apiKey) required
      if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Key"))) {
        localVarRequestOptions.HeaderParameters.Add("X-API-Key", this.Configuration.GetApiKeyWithPrefix("X-API-Key"));
      }
      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request

      var localVarResponse = await this.AsynchronousClient
          .PostAsync<PluginVersionInfo>("/plugins", localVarRequestOptions, this.Configuration, cancellationToken)
          .ConfigureAwait(false);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("SubmitPlugin", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Updates the README content for a specific plugin version. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose README is being updated.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The new README content to replace the existing one. (optional)</param>
    /// <returns>string</returns>
    public string UpdatePluginReadme(Guid pluginId, Guid versionId, string? body = default(string?)) {
      ApiResponse<string> localVarResponse = UpdatePluginReadmeWithHttpInfo(pluginId, versionId, body);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Updates the README content for a specific plugin version. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose README is being updated.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The new README content to replace the existing one. (optional)</param>
    /// <returns>ApiResponse of string</returns>
    public ApiResponse<string> UpdatePluginReadmeWithHttpInfo(Guid pluginId, Guid versionId,
                                                              string? body = default(string?)) {
      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
          "text/markdown", "application/json"
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "text/markdown"
      };

      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.PathParameters.Add("pluginId", ClientUtils.ParameterToString(pluginId)); // path parameter
      localVarRequestOptions.PathParameters.Add("versionId",
          ClientUtils.ParameterToString(versionId)); // path parameter
      localVarRequestOptions.Data = body;

      // authentication (apiKey) required
      if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Key"))) {
        localVarRequestOptions.HeaderParameters.Add("X-API-Key", this.Configuration.GetApiKeyWithPrefix("X-API-Key"));
      }
      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request
      var localVarResponse = this.Client.Put<string>("/plugins/{pluginId}/{versionId}/readme", localVarRequestOptions,
          this.Configuration);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("UpdatePluginReadme", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

    /// <summary>
    /// Updates the README content for a specific plugin version. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose README is being updated.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The new README content to replace the existing one. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of string</returns>
    public async Task<string> UpdatePluginReadmeAsync(Guid pluginId, Guid versionId, string? body = default(string?),
                                                      CancellationToken cancellationToken =
                                                          default(CancellationToken)) {
      ApiResponse<string> localVarResponse =
          await UpdatePluginReadmeWithHttpInfoAsync(pluginId, versionId, body, cancellationToken).ConfigureAwait(false);
      return localVarResponse.Data;
    }

    /// <summary>
    /// Updates the README content for a specific plugin version. 
    /// </summary>
    /// <exception cref="UnrealPluginManager.WebClient.Client.ApiException">Thrown when fails to make API call</exception>
    /// <param name="pluginId">The unique identifier of the plugin whose README is being updated.</param>
    /// <param name="versionId">The unique identifier for the specific version of the plugin.</param>
    /// <param name="body">The new README content to replace the existing one. (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (string)</returns>
    public async Task<ApiResponse<string>> UpdatePluginReadmeWithHttpInfoAsync(
        Guid pluginId, Guid versionId, string? body = default(string?),
        CancellationToken cancellationToken = default(CancellationToken)) {

      RequestOptions localVarRequestOptions = new RequestOptions();

      string[] _contentTypes = new string[] {
          "text/markdown", "application/json"
      };

      // to determine the Accept header
      string[] _accepts = new string[] {
          "text/markdown"
      };


      var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
      if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

      var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
      if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

      localVarRequestOptions.PathParameters.Add("pluginId", ClientUtils.ParameterToString(pluginId)); // path parameter
      localVarRequestOptions.PathParameters.Add("versionId",
          ClientUtils.ParameterToString(versionId)); // path parameter
      localVarRequestOptions.Data = body;

      // authentication (apiKey) required
      if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-API-Key"))) {
        localVarRequestOptions.HeaderParameters.Add("X-API-Key", this.Configuration.GetApiKeyWithPrefix("X-API-Key"));
      }
      // authentication (oauth2) required
      // oauth required
      if (!string.IsNullOrEmpty(this.Configuration.AccessToken) &&
          !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization")) {
        localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
      }

      // make the HTTP request

      var localVarResponse = await this.AsynchronousClient.PutAsync<string>("/plugins/{pluginId}/{versionId}/readme",
          localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

      if (this.ExceptionFactory != null) {
        Exception _exception = this.ExceptionFactory("UpdatePluginReadme", localVarResponse);
        if (_exception != null) throw _exception;
      }

      return localVarResponse;
    }

  }
}